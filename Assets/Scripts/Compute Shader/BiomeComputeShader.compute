#pragma kernel CSMain
#include "Assets/Libraries/ShaderSimplex/ShaderSimplex.cginc" // include this file with useful noise functions credit: https://forum.unity.com/threads/2d-3d-4d-optimised-perlin-noise-cg-hlsl-library-cginc.218372/ 


struct biomeDescription // struct so we can put this on one buffer
{
    int id;
    float2 tempRange;
    float2 humRange;
    float4 colour;
}; 

RWTexture2D<float4> colourMap; // will create a texture that shows the colours on the map of each biome
RWStructuredBuffer<biomeDescription> biomesBuffer; // holds the data for each biome

int biomeNums; // the number of buffers in the biome
float2 positionOffset; // where the noise should start ie tile x=1,y=1 offset = seed + float2(100,100)
float noiseFrequency=1; // the frequency of noise
const float2 humToTempOffset= float2(1245,6438); // fairly random offset between the temp and humidity maps 
float2 TextureSize;


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 position= id.xy+positionOffset;

    float hum= 0.5*(snoise(noiseFrequency*position)+1);
    float temp= 0.5*(snoise(noiseFrequency*position+float2(100,100))+1);

    biomeDescription positionbiome;

    for(int biome=0;biome<biomeNums;biomeNums++) // iterate through each biome so we know where this position falls
    {
        biomeDescription lookBiome= biomesBuffer[biome];// current biome were iterating through

        // hum/tempRange are x is lower bounds y is upper bound
        bool inTempRange=(lookBiome.tempRange.x<temp && temp<lookBiome.tempRange.y); 
        bool inHumRange=(lookBiome.humRange.x<hum && hum<lookBiome.humRange.y);
        if(inTempRange && inHumRange)
        {
            positionbiome=lookBiome; // when its found the biome type then set it
            break;
        }

    }

    // set data now
   // colourMap[id.xy]= positionbiome.colour;
   colourMap[id.xy]= float4(hum,temp,0,1);//float4(hum,temp,0,1);
   


}
 